<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width,
                                   initial-scale=1.0,
                                   user-scalable=yes">
    <meta name="author" content="Daniel Jour">
            <meta name="dcterms.date" content="2017-12-27">
                <title>Shouldn't I specify correct handling of return values to the compiler? â€“ musteresel's blog</title>
    <style type="text/css">code{white-space: pre;}</style>
        <style type="text/css">
      body {
      padding-left: 1em;
      padding-right: 1em;
      margin-left: auto;
      margin-right: auto;
      max-width: 42em;
      font-size: 100%;
      font-family: Verdana, Geneva, sans-serif;
      line-height: 24px;
      }
      div.sourceCode {
      line-height: normal;
      }
      .heading {
      color: #002560;
      }
      a:link, a:visited {
      color: #008aa3;
      text-decoration: none;
      }
      a:hover {
      color: #004d60;
      text-decoration: none;
      }
      a:active {
      color: white;
      background-color: #008aa3;
      }
      footer {
      font-size: 75%;
      }
      .not-my-info {
      font-size: 0;
      }
      pre > code {
      overflow-x: auto;
      display: block;
      }
    </style>
        <style type="text/css">
      div.sourceCode { overflow-x: auto; }
      table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
        margin: 0; padding: 0; vertical-align: baseline; border: none; }
      table.sourceCode { width: 100%; line-height: 100%; }
      td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
      td.sourceCode { padding-left: 5px; }
      code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code > span.dt { color: #902000; } /* DataType */
      code > span.dv { color: #40a070; } /* DecVal */
      code > span.bn { color: #40a070; } /* BaseN */
      code > span.fl { color: #40a070; } /* Float */
      code > span.ch { color: #4070a0; } /* Char */
      code > span.st { color: #4070a0; } /* String */
      code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code > span.ot { color: #007020; } /* Other */
      code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code > span.fu { color: #06287e; } /* Function */
      code > span.er { color: #ff0000; font-weight: bold; } /* Error */
      code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      code > span.cn { color: #880000; } /* Constant */
      code > span.sc { color: #4070a0; } /* SpecialChar */
      code > span.vs { color: #4070a0; } /* VerbatimString */
      code > span.ss { color: #bb6688; } /* SpecialString */
      code > span.im { } /* Import */
      code > span.va { color: #19177c; } /* Variable */
      code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code > span.op { color: #666666; } /* Operator */
      code > span.bu { } /* BuiltIn */
      code > span.ex { } /* Extension */
      code > span.pp { color: #bc7a00; } /* Preprocessor */
      code > span.at { color: #7d9029; } /* Attribute */
      code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    </style>
            <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <header>
      <h1 class="heading"><a href="../../../index.html">musteresel's blog</a></h1>
    </header>
    <hr>
    <article>
            <header>
        <h1 class="title">Shouldn't I specify correct handling of return values to the compiler?</h1>
                                <p class="date">2017-12-27</p>
                        <p class="tags">tagged:
                    <a href="../../../posts/tagged/c/index.html">c</a>,
                    <a href="../../../posts/tagged/c++/index.html">c++</a>,
                    <a href="../../../posts/tagged/programming-language-theory/index.html">programming-language-theory</a></p>
              </header>
            <p>Have you ever seen something like the following? Do you immediately see the issue?</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// ...</span>
<span class="cf">if</span> (size &lt; necessary_size) {
  size = size * <span class="dv">2</span>;
  buffer = realloc(buffer, size);
  <span class="cf">if</span> (buffer == NULL) {
    <span class="co">// out of memory, sorry</span>
    <span class="co">// some kind of error handling / logging</span>
  }
}
<span class="co">// ...</span></code></pre></div>
<p>This is a memory leak, because the memory <code>buffer</code> originally pointed to cannot be freed when <code>realloc</code> fails. There's no pointer pointing to it anymore, after all.</p>
<p>I'll try to formulate rules which - when followed - would make the above error impossible to occur:</p>
<ol style="list-style-type: decimal">
<li>The pointer passed in as first argument must not be a temporary.</li>
<li>The returned pointer must not be assigned to the pointer which was passed as first argument.</li>
</ol>
<p>Of course I can add such rules to the documentation of the <code>realloc</code> function, but - sadly - that won't really help. People just don't always read documentations. Or they forget what they read. Thus it would be much better if I could <em>specify these rules such that the compiler understands</em> and <strong>enforces</strong> them.</p>
<p>In C++ I can acutally express rule 1, at least somewhat:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> void_p = <span class="dt">void</span> *
<span class="dt">void</span> * foo(void_p &amp;) {
  <span class="co">// stuff</span>
  <span class="cf">return</span> NULL;
}</code></pre></div>
<p>If I now try to use <code>foo</code> with a temporary, then the compiler will bark:</p>
<pre><code>error: invalid initialization of non-const reference of type &#39;void*&amp;&#39; from an rvalue of type &#39;void*&#39;</code></pre>
<p>A drawback here is that this only works with non-const references ... and as such allows me to do nasty things:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * foo(void_p &amp; x) {
  x = NULL; <span class="co">// there goes your pointer, HA!</span>
  <span class="co">// stuff</span>
  <span class="cf">return</span> NULL;
}</code></pre></div>
<p>But, for rule 2, there's no real way of telling the compiler what is allowed and what isn't. I think, though, that a feature like this could turn out really helpfull. A completely blue-eyed take:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> passed_pointer = <span class="er">$</span>function.arguments()[<span class="dv">0</span>].source_variable();
<span class="cf">if</span> (passed_pointer.aliases().size() == <span class="dv">0</span>
    &amp;&amp; <span class="er">$</span>function.return_value().assigned_to(only_pointer)) {
  compiler.fail(<span class="st">&quot;Return value overwrites only available pointer to&quot;</span>
                <span class="st">&quot; previously allocated memory!&quot;</span>);
}</code></pre></div>
<p>The syntax for this thought experiment is borrowed from the <a href="https://www.fluentcpp.com/2017/08/04/metaclasses-cpp-summary/">metaclasses proposal for C++</a> (if you haven't read about this, please do now! It's an excellent idea). The example above though also shows why implementing such a feature could turn out to be somewhere between hard and impossible:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> baz(<span class="dt">void</span> **pointer_var, <span class="dt">void</span> *  buffer) {
  *pointer_var = foo(buffer);
}

<span class="dt">void</span> bar() {
  <span class="dt">void</span> *pointers[] = {NULL, malloc(<span class="dv">10</span>), NULL};
  <span class="co">// imagine reliable error handling here</span>
  <span class="dt">int</span> index = rand() % <span class="dv">3</span>;
  baz(pointers + index, pointers + <span class="dv">1</span>);
}</code></pre></div>
<p>Inside of <code>baz</code>, there's the parameter <code>buffer</code> which is a pointer to the allocated memory. It doesn't get assigned, to. Thus everything seems fine. Until I leave <code>baz</code>. Do I now have a pointer to the allocated memory or not? This depends on the <em>runtime</em> value returned by <code>rand()</code>. Should the compiler be able to deal with such situations? Can it even? Or will this turn out to be a (another) lost case against the halting problem?</p>
<p>Instead of giving the compiler <em>rules to enforce</em> - which leads to a conservative behaviour ... if it cannot be sure that the rules are adhered to, then it's an error - it could be easier to give the compiler <em>patterns for common errors</em>. These could be handled more permissive: If it cannot match the situation to any of the patterns, then it assumes that everything is fine. Only if a pattern that's <em>known</em> to lead to an error is found, then issue an error.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> (<span class="er">$</span>function.arguments()[<span class="dv">0</span>].source_variable()
    == <span class="er">$</span>function.return_value().target_variable()) {
  compiler.fail(<span class="st">&quot;Looks like you&#39;re assigning the return value to the&quot;</span>
                <span class="st">&quot; same variable which you also used as first&quot;</span>
                <span class="st">&quot; argument; that&#39;s a bad idea!&quot;</span>);
}</code></pre></div>
<p>This could also catch simpler issues, for example when the return value is not checked against &quot;special&quot; values (like <code>NULL</code>) inside the calling function and also not passed to any other function nor returned from the calling function:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f(Cache &amp; cache) {
  <span class="dt">char</span> * b = cache.get_buffer(); <span class="co">// assume this could return nullptr</span>
  <span class="dt">char</span> c;
  <span class="bu">std::</span>cin &gt;&gt; c;
  b[<span class="dv">0</span>] = c;
}</code></pre></div>
<p>This could then also catch issues like <a href="https://github.com/uzbl/uzbl/issues/393">this one I found in uzbl</a> where <a href="https://developer.gnome.org/glib/stable/glib-IO-Channels.html#g-io-channel-write-chars"><code>g_io_channel_write_chars</code></a> was used but the special return value <code>G_IO_STATUS_AGAIN</code> (which indicates that the function should be called again ... due to a non blocking socket not being ready, for example) wasn't handled in any way.</p>
<p><strong>But is this really the job of the compiler? Shouldn't this be some kind of code analysis tool?</strong> I think in the end, this wouldn't matter. Type checking is also some kind of code analysis. It's part of the compiler. Style checking is another kind of code analysis. It's most often not part of a compiler but a separate tool.</p>
<p>Actually, I think there <em>are</em> already tools capable of finding errors like the ones I presented here. But I think the most important issue with these tools is that they have some kind of a database of &quot;known error-prone patterns&quot;. This database is continuously extended by the users of the analysis tool. <strong>It would be better if the developer writing a function could specify the correct handling of its return values in a standardized way, directly next to the function itself.</strong></p>
            <hr>
      <footer>
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSfV7TfT4OIcpopar3hBoLnzHBmbOi85ysjX23cQsvKzBCy4Dw/viewform?usp=pp_url&entry.1949939362=posts/2017/12/specify-correct-handling-return-values.html">
          Send me a message regarding this post</a>
      </footer>
      
    </article>
    <hr>
    <footer>
      <a href="../../../legal.html">Legal Notice / Impressum</a>
    </footer>
  </body>
</html>
